---
title: "Vue 3のパフォーマンス最適化のポイント"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["vue", "vue3", "performance", "javascript"]
published: false
---

Vue 3でパフォーマンスを意識する上で重要なのは、主に「**バンドルサイズの削減**」「**レンダリングの効率化**」「**メモリ管理**」の3点です。

Vue 3は、Vue 2に比べてこれらの点で多くの改善が施されていますが、開発者が意識することでさらにパフォーマンスを引き出すことができます。

## 📦 バンドルサイズの削減 (Tree-shaking)

Vue 3は、Composition APIをはじめとする多くの機能がモジュール化されています。これにより、**Tree-shaking（ツリーシェイキング）**が非常に効果的に機能します。

### Tree-shakingとは？

ビルド時に、実際にコードで使用されていない（importされていない）機能を最終的な成果物（バンドルファイル）から除外する仕組みです。

### 意識したいポイント

- **必要なものだけを `import` する**: ライブラリ全体ではなく、必要な関数やコンポーネントだけを具体的に `import` しましょう。

例えば、以下のように使うものだけを指定します：

```javascript
import { ref, computed } from 'vue'
```

## ⚡ レンダリングの効率化

Vue 3の仮想DOM (Virtual DOM) は、コンパイラによって大幅に最適化されています。静的な部分と動的な部分（変更される可能性がある部分）をビルド時に区別し、実行時の差分チェックを最小限に抑えます。

### `v-for` と `key`

`v-for` を使う際は、**必ず一意で安定した `key`** を指定しましょう。`key` は、Vueが各要素を識別し、最小限のDOM操作でリストを更新するために重要です。

インデックス (`index`) を `key` に使うのは、リストの順序が変わったり、要素が追加・削除されたりする場合、パフォーマンス低下の原因となるため避けた方が良いでしょう。

### `v-if` vs `v-show`

- **`v-if`**: 条件が `true` になるまでレンダリング自体を行いません（DOMが生成されません）。初期表示のコストは低いですが、切り替え時にはコンポーネントの破棄と再生成が伴います。
- **`v-show`**: 常にDOM要素としてレンダリングされますが、`display: none;` によって表示・非表示が切り替えられます。初期表示コストは `v-if` より高いですが、頻繁に切り替える場合のコストは低いです。

### `keep-alive`

一度レンダリングしたコンポーネントの状態をメモリ内に保持します。タブ切り替えなどでコンポーネントを頻繁に切り替える際、再レンダリングのコストを削減できます。

### `shallowRef` と `shallowReactive`

`ref` や `reactive` はデフォルトで深い階層までリアクティブ（変更を監視）にします。非常に大きなデータや、ネストが深いオブジェクトの場合、この監視がオーバーヘッドになることがあります。

`shallowRef` や `shallowReactive` を使うと、第一階層のみをリアクティブにし、パフォーマンスを向上させることができます。

## 🧠 メモリ管理

特にComposition APIを使う場合、メモリリーク（不要になったメモリが解放されない問題）に注意が必要です。

### `onUnmounted` でのクリーンアップ

`setup` 関数や `<script setup>` 内で `window` にイベントリスナーを追加したり、`setInterval` などのタイマーを設定したりした場合、コンポーネントが破棄されるタイミング（`onUnmounted` フック）で、それらを明示的に解除する必要があります。

これを怠ると、コンポーネントが破棄された後もリスナーやタイマーが残り続け、メモリリークの原因となります。

```vue
<script setup>
import { onMounted, onUnmounted } from 'vue'

function onScroll() {
  // スクロール処理
}

onMounted(() => {
  window.addEventListener('scroll', onScroll)
})

// コンポーネントが破棄されるときに、必ずイベントリスナーを削除する
onUnmounted(() => {
  window.removeEventListener('scroll', onScroll)
})
</script>
```

## 🧩 その他の最適化

上記に加えて、一般的なWebパフォーマンスのベストプラクティスも同様に重要です。

### コード分割 (Code Splitting)

Vue Router を使っている場合、ルート（ページ）ごとにコンポーネントを非同期で読み込む（遅延読み込み）設定が簡単にできます。これにより、初期表示に必要なJavaScriptのサイズを最小限に抑えられます。

### 不要なリアクティビティの回避

変更されることのない巨大な静的データ（例：外部から取得した設定一覧など）は、`ref` や `reactive` に入れる必要はありません。

`markRaw` を使うことで、オブジェクトがリアクティブになるのを防ぎ、パフォーマンスを確保できます。

### 画像の最適化

- WebPなどのモダンな画像フォーマットを使用する
- 画像の遅延読み込み (Lazy Loading) を導入する