---
title: "掲示板のスレッドを作成するページを作成してみた(Firebase編)"
emoji: "✨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Vue","Vue3","プログラミング"]
published: false
---

## 関連記事
:::details 関連記事一覧

https://zenn.dev/shunsuke_stack/articles/3b7759f0053ca6

https://zenn.dev/shunsuke_stack/articles/bdf5b784bd6f8b

https://zenn.dev/shunsuke_stack/articles/88dedd7c5a2341

https://zenn.dev/shunsuke_stack/articles/65c1d38ed8c694

:::

## GitHub
https://github.com/nakajima-sh-cnctor/nuxt4-firebase-chat


## Firebase Firestore Database 導入設定
入力したデータを管理するDBに今回「Firestore Database」を採用します

### Firestore Databaseとは？
Firebase Firestoreは、Googleが提供する**NoSQLドキュメントデータベース**です。モバイルアプリやWebアプリケーションのバックエンドとして、データの保存、同期、クエリを簡単かつ効率的に行うために設計されています。サーバーレスアーキテクチャを採用しているため、開発者はサーバーの管理やスケーリングを気にすることなく、アプリケーション開発に集中できます。



---

#### 主な特徴

Firestoreは、最新のアプリケーション開発に求められる多くの強力な機能を備えています。

* **リアルタイム同期**: データが変更されると、接続されているすべてのクライアントにほぼ瞬時に変更が通知され、データが同期されます。これにより、チャットアプリや共同編集ツールなど、リアルタイム性が重要なアプリケーションを簡単に構築できます。

* **オフラインサポート**: モバイルアプリやWebアプリがオフラインになっても、ローカルにキャッシュされたデータを操作できます。オンラインに復帰すると、変更点が自動的にサーバーと同期されます。

* **柔軟なデータモデル**: データを「ドキュメント」と「コレクション」という階層構造で管理します。ドキュメントはJSONライクな形式で、様々なデータ型を柔軟に格納できます。このスキーマレスな性質により、開発の初期段階や仕様変更に迅速に対応できます。

* **強力なクエリ機能**: 単純なデータの取得だけでなく、複数の条件を組み合わせた複雑なクエリや、並べ替え、フィルタリングが可能です。これにより、必要なデータを効率的に取得できます。

* **優れたスケーラビリティ**: アプリケーションの負荷に応じて自動的にスケールするため、ユーザー数の急増や大量のデータアクセスにも対応できます。Google Cloudのインフラ上で稼働しており、高い可用性と耐久性を誇ります。

* **強固なセキュリティ**: Firebase Authenticationと連携し、詳細なセキュリティルールを定義できます。ユーザーごとやドキュメントごとにアクセス権限を細かく制御することで、データを安全に保護します。

---

#### 料金体系

Firestoreの料金は、主に以下の要素に基づく**従量課金制**です。

* **ドキュメントの読み取り、書き込み、削除の回数**
* **ストレージ容量**
* **ネットワーク帯域幅**

ただし、 generousな**無料枠**が設けられており、小規模なアプリケーションや開発段階では無料で利用できる場合が多くあります。

* **読み取り**: 1日あたり50,000回まで無料
* **書き込み**: 1日あたり20,000回まで無料
* **削除**: 1日あたり20,000回まで無料
* **ストレージ**: 1GiBまで無料

プランは無料の「Sparkプラン」と従量課金制の「Blazeプラン」の2種類があり、無料枠を超えた分だけ料金が発生します。

---

#### ユースケース

Firestoreの柔軟性とリアルタイム性は、様々なアプリケーションで活用されています。

* **リアルタイムチャットアプリ**: メッセージの即時送受信を実現します。
* **ソーシャルメディアアプリ**: ユーザーの投稿や「いいね」などのアクティビティをリアルタイムにフィードに反映させます。
* **共同編集ツール**: 複数のユーザーが同時にドキュメントやデータを編集し、変更を即座に共有します。
* **ゲーム**: プレイヤーのスコアやステータスをリアルタイムに更新・同期します。
* **Eコマースアプリ**: 在庫状況や注文ステータスをリアルタイムに管理します。

---

#### Realtime Databaseとの違い

Firebaseには、Firestoreの他に**Realtime Database**というもう一つのデータベースがあります。どちらもリアルタイム同期を特徴としていますが、いくつかの重要な違いがあります。

| 機能 | Cloud Firestore | Realtime Database |
| --- | --- | --- |
| **データモデル** | ドキュメントとコレクション（階層的） | 単一の巨大なJSONツリー |
| **クエリ** | 複合的なクエリ、インデックス作成が可能 | ディープクエリ、並べ替えやフィルタリングに制限 |
| **スケーラビリティ**| 自動でグローバルにスケール | 手動でのシャーディングが必要になる場合がある |
| **リージョン** | マルチリージョンまたはリージョンを選択可能 | リージョンは単一 |
| **料金体系** | 読み取り/書き込み/削除の回数、ストレージ容量 | ストレージ容量、ダウンロード帯域幅 |
| **オフラインサポート**| より高度で堅牢（モバイル、Web） | モバイルのみ |
| **適した用途** | 複雑なデータ構造を持つ大規模アプリ、Eコマースなど | 状態同期、プレゼンスなど単純なデータの高速な同期 |

**どちらを選ぶべきか？**

* **Firestore**は、より高度なクエリ、大規模なデータセット、高いスケーラビリティが求められる新しいプロジェクトに推奨されます。
* **Realtime Database**は、単純なJSONデータを扱い、低レイテンシーでの同期が最優先される特定のユースケース（例：オンラインプレゼンスの表示など）に適しています。

多くの場合、新規開発ではより多機能でスケーラブルな**Firestoreが第一の選択肢**となるでしょう。

## Firebaseの設定ファイルの変更
Firestore Databaseを使用可能にするように設定ファイルを変更する。

```diff ts
import { initializeApp } from 'firebase/app'
import { getAuth, type Auth } from 'firebase/auth'
+ import { getFirestore, type Firestore } from 'firebase/firestore'
import { defineNuxtPlugin, useRuntimeConfig } from 'nuxt/app'

interface FirebaseConfig {
  apiKey: string
  authDomain: string
  projectId: string
  storageBucket: string
  messagingSenderId: string
  appId: string
}

export default defineNuxtPlugin(() => {
  const config = useRuntimeConfig()

  // 環境変数が設定されていない場合はエラーを表示
  if (
    !config.public.firebase?.apiKey ||
    config.public.firebase.apiKey === 'your-api-key'
  ) {
    console.log('現在の設定:', config.public.firebase)
    console.error(
      'Firebase設定が正しく設定されていません。.envファイルを確認してください。'
    )
    return {
      provide: {
        auth: null as Auth | null,
+        firestore: null as Firestore | null,
      },
    }
  }

  const firebaseConfig: FirebaseConfig = {
    apiKey: config.public.firebase.apiKey,
    authDomain: config.public.firebase.authDomain,
    projectId: config.public.firebase.projectId,
    storageBucket: config.public.firebase.storageBucket,
    messagingSenderId: config.public.firebase.messagingSenderId,
    appId: config.public.firebase.appId,
  }

  // Firebase初期化
  const app = initializeApp(firebaseConfig)
  const auth = getAuth(app)
+  const firestore = getFirestore(app)

  return {
    provide: {
      auth: auth as Auth | null,
+      firestore: firestore as Firestore,
    },
  }
})

```

## スレッド用のcomposablesを作成する
スレッド作成に対してFirebaseとやりとりを行う処理を作成する。
今回はスレッドを作成する処理を追加していく

```ts:app/composables/useThread.ts
import {
  collection,
  addDoc,
  serverTimestamp,
  type Firestore,
} from 'firebase/firestore'
import { useNuxtApp } from 'nuxt/app'

export interface Thread {
  id?: string
  title: string
  description: string
  createdAt: Date | null
  updatedAt: Date | null
  authorId: string
  authorName: string
}

export const useThread = () => {
  const { $firestore } = useNuxtApp()
  const firestore = $firestore as Firestore | null
  const loading = ref(false)

  // スレッドを作成
  const createThread = async (
    title: string,
    description: string,
    authorId: string,
    authorName: string
  ) => {
    if (!firestore) {
      return {
        thread: null,
        error: new Error('Firestoreが初期化されていません'),
      }
    }

    try {
      loading.value = true
      const threadData = {
        title,
        description,
        authorId,
        authorName,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      }

      const docRef = await addDoc(collection(firestore, 'threads'), threadData)

      return {
        thread: {
          id: docRef.id,
          ...threadData,
          createdAt: null,
          updatedAt: null,
        } as Thread,
        error: null,
      }
    } catch (error) {
      return {
        thread: null,
        error: error as Error,
      }
    } finally {
      loading.value = false
    }
  }

  return {
    loading: readonly(loading),
    createThread,
  }
}
```

### FirestoreのaddDoc()

`Firestore` の `addDoc()` は、コレクションに新しいドキュメントを追加するための非常に重要で便利な関数です。ドキュメントIDを自動で生成してくれるのが最大の特徴です。

ここでは `addDoc()` について、その仕組み、使い方、そして類似の `setDoc()` との違いなどを詳しく解説します。

-----

#### **`addDoc()` の概要**

`addDoc()` は、Cloud Firestore データベースの指定したコレクション内に、新しいドキュメントを追加するための関数です。

一番のポイントは、**ドキュメントIDをFirestoreが自動的に生成してくれる**点です。自分で一意のIDを考える必要がないため、新しいデータを手軽にどんどん追加していくような場合に非常に役立ちます。例えば、ブログの投稿、チャットのメッセージ、ログデータなど、作成順に意味があり、ID自体に特別な意味を持たせる必要がないデータに適しています。

-----

##### **`addDoc()` の主な特徴**

  * **自動ID生成**: Firestoreがタイムスタンプに基づいた、ほぼ重複することのないユニークなIDを自動で割り当てます。
  * **非破壊的な追加**: 既存のドキュメントを上書きする心配がありません。常に新しいドキュメントとして追加されます。
  * **シンプルな記述**: ドキュメントIDを自分で管理する必要がないため、コードが簡潔になります。

-----

#### **`addDoc()` と `setDoc()` の違い**

Firestoreには `addDoc()` とよく似た `setDoc()` という関数もありますが、明確な違いがあります。

| 機能 | `addDoc()` | `setDoc()` |
| :--- | :--- | :--- |
| **ドキュメントID** | **自動生成** | **自分で指定**する必要がある |
| **主な用途** | 新しいデータを**追加**する | 特定のIDを持つドキュメントを**作成・上書き**する |
| **参照の指定** | `collection()` でコレクション参照を指定 | `doc()` でドキュメント参照（IDまで含めて）を指定 |

##### **使い分けの例**

  * **`addDoc()` が適しているケース**

      * ユーザーの投稿履歴
      * チャットのメッセージ
      * センサーのログデータ
      * ショッピングカートに商品を追加する

  * **`setDoc()` が適しているケース**

      * ユーザープロフィール（ユーザーIDをドキュメントIDにする）
      * 商品の在庫情報（商品IDをドキュメントIDにする）
      * 設定情報など、IDが固定されているドキュメントの更新

**`setDoc()` のコード例**
`setDoc()` では、`doc()` を使ってドキュメントIDまで指定している点に注目してください。

```javascript
import { doc, setDoc } from "firebase/firestore";

// "user123" というIDを自分で指定
const docRef = doc(db, "users", "user123");
await setDoc(docRef, {
  name: "Taro Yamada",
  email: "taro@example.com"
});
```

`setDoc()` は、指定したIDのドキュメントが存在しない場合は新規作成し、存在する場合は（デフォルトでは）ドキュメント全体を新しいデータで**完全に上書き**します。部分的に更新したい場合は、`setDoc` に `{ merge: true }` オプションを渡すか、`updateDoc` を使用します。

-----

#### **まとめ**

`addDoc()` は、Firestoreに新しいデータを簡単かつ安全に追加するための基本となる関数です。ドキュメントIDを自動生成してくれる手軽さが最大のメリットであり、多くのアプリケーションで頻繁に使用されます。

一方で、ドキュメントのIDを自分で管理したい場合は `setDoc()` を使う、というように両者の違いを理解し、用途に応じて適切に使い分けることがFirestoreを効果的に活用する鍵となります。

### Firestoreのcollection()

Firestoreの**コレクション**は、ドキュメントを格納するための入れ物、つまり**フォルダ**のようなものです。Firestoreのデータを整理するための最も基本的な単位の一つです。

ここでは、コレクションがどのようなものか、その特徴や使い方を詳しく解説します。

-----

#### **コレクションの基本概念**

Cloud Firestoreのデータモデルは、**コレクション**と**ドキュ\_メント**という2つの主要な要素で構成されています。

  * **コレクション (Collection)**: ドキュメントを格納する場所です。データベースのテーブルや、PCのフォルダに似ています。
  * **ドキュメント (Document)**: 実際のデータを格納する場所です。キーとバリューのペア（フィールド）で構成され、JSONオブジェクトのように柔軟なデータ構造を持つことができます。

この関係を視覚的に表すと、以下のようになります。

**コレクションの中にはドキュメントしか格納できません。** コレクションの中に別のコレクションを直接入れることはできず、必ず「コレクション → ドキュメント → コレクション → ドキュメント...」という階層構造になります。

-----

#### **主な特徴**

##### **1. ドキュメントのコンテナ**

コレクションの唯一の役割は、**ドキュメントをまとめること**です。例えば、`users` というコレクションを作って各ユーザーの情報をドキュメントとして保存したり、`products` というコレクションで商品情報を管理したりします。

```
users (コレクション)
├── user_A (ドキュメント)
│   ├── name: "Alice"
│   └── email: "alice@example.com"
└── user_B (ドキュメント)
    ├── name: "Bob"
    └── email: "bob@example.com"
```

##### **2. 柔軟なデータ構造**

同じコレクション内のドキュメントが、**必ずしも同じフィールド（データの項目）を持つ必要はありません。**

例えば、`users` コレクション内のあるドキュメントには `name` と `email` しかなくても、別のドキュメントには `age` や `address` を追加できます。この柔軟性がNoSQLデータベースであるFirestoreの大きな利点です。

##### **3. スケーラビリティ**

Firestoreのクエリ（データ検索）のパフォーマンスは、コレクション内のドキュメント数に依存しません。コレクションに100個のドキュメントがあっても、100万個のドキュメントがあっても、特定のドキュメントを取得する速度はほぼ同じです。これは、Firestoreが非常に大規模なアプリケーションにも対応できる理由の一つです。

##### **4. 暗黙的な作成と削除**

コレクションは、**明示的に作成する必要がありません。**

  * **作成**: あるコレクションに最初のドキュメントを追加すると、そのコレクションは自動的に作成されます。
  * **削除**: あるコレクション内のすべてのドキュメントを削除すると、そのコレクションは自動的に存在しなくなります（コンソール上からは見えなくなります）。

コレクション自体を空のまま作成したり、管理したりする操作は基本的にありません。

-----

#### **サブコレクション**

ドキュメントの中に、さらに別のコレクションを作成することができます。これを**サブコレクション**と呼びます。

これにより、関連性の高いデータを階層的に整理できます。

**例：ブログ投稿とコメント**

`posts` コレクションに各ブログ記事のドキュメントを保存し、各記事ドキュメントの中に `comments` というサブコレクションを作成して、その記事へのコメントを保存します。

```
posts (コレクション)
└── post_123 (ドキュメント)
    ├── title: "Firestore入門"
    ├── content: "..."
    └── comments (サブコレクション)  <-- ドキュメントの中にコレクション
        ├── comment_abc (ドキュメント)
        │   ├── user: "Alice"
        │   └── text: "分かりやすいです！"
        └── comment_xyz (ドキュメント)
            ├── user: "Bob"
            └── text: "参考になりました。"
```

###### **サブコレクションの利点**

  * **データの整理**: 親ドキュメントに関連するデータをまとめて管理できます。
  * **クエリの効率**: 「`post_123` のコメントだけを取得する」といったクエリを非常に高速に実行できます。親ドキュメントのIDが分かっていれば、関連データに素早くアクセスできます。

-----

#### **設計のベストプラクティス**

  * **命名規則**: コレクション名は、複数形（例：`users`, `products`, `orders`）で、短く分かりやすい名前にするのが一般的です。
  * **データ構造**: どのようなデータをどのようなコレクション/サブコレクションに分けるかは、アプリの要件（特にデータの取得方法）によって決まります。データをどう取得したいかを考えてから、構造を設計するのが重要です。
  * **ルートコレクションの活用**: 関連性の低いデータは、無理にサブコレクションにせず、別の独立したルートコレクションとして作成する方が良い場合も多いです。

#### **まとめ**

Firestoreのコレクションは、データを整理するための**フォルダ**であり、その中に実際のデータが入った**ドキュメント**を格納します。このシンプルな構造と、サブコレクションによる階層化を理解することが、Firestoreを効果的に使いこなすための第一歩です。

### FirestoreのserverTimestamp()

Firestore の `serverTimestamp` は、ドキュメントが実際に **Firestore のサーバーで書き込まれた時刻**を記録するための特別な値です。これにより、ユーザーのデバイス（クライアント）の時刻に左右されない、正確で一貫性のあるタイムスタンプを保存できます。

-----

#### **`serverTimestamp` の基本**

`serverTimestamp()` は、データを書き込む際に使用する**特別な関数**です。ドキュメントのフィールドにこの関数を指定すると、データが Firestore サーバーに到達した時点のタイムスタンプに置き換えられます。

**主な目的**:

  * 投稿日時、更新日時、作成日時など、**客観的な時刻**を記録する。
  * ユーザーのデバイスの時計が不正確（手動で変更されている、タイムゾーンが違うなど）な場合でも、信頼できる時刻を保証する。


##### **書き込まれるデータ**

実際にFirestoreに保存されると、`serverTimestamp()` は **Timestamp** 型のオブジェクトに変換されます。このオブジェクトには、秒 (`seconds`) とナノ秒 (`nanoseconds`) の情報が含まれています。

-----

#### **なぜ `new Date()` ではなく `serverTimestamp()` を使うのか？**

クライアント側で `new Date()` を使って時刻を生成することもできますが、`serverTimestamp()` にはそれを上回る重要な利点があります。

| | `serverTimestamp()` | `new Date()` (クライアント側) |
| :--- | :--- | :--- |
| **信頼性** | ✅ **非常に高い**。全てのデータが一つの信頼できる時計（サーバー）を基準にする。 | ❌ **低い**。ユーザーのデバイスの時計に依存するため、不正確な可能性がある。 |
| **一貫性** | ✅ **保証される**。世界中のどこからアクセスしても、同じ基準の時刻が記録される。 | ❌ **保証されない**。タイムゾーンやユーザーの設定によって時刻がバラバラになる。 |
| **不正防止** | ✅ **強い**。ユーザーは時刻を操作できない。 | ❌ **弱い**。ユーザーがデバイスの時計を変更すれば、意図しない時刻を保存できてしまう。 |
| **オフライン時**| ✅ **対応**。オフラインで書き込んでも、オンライン復帰時にサーバー時刻が適用される。 | ⚠️ その瞬間のクライアント時刻が記録され、後で同期される。 |

**例えるなら…**
`new Date()` は「各自が持っている腕時計の時間」で、`serverTimestamp()` は「中央にある信頼できる標準時」です。全員が中央の時計を見ることで、時間のズレがなくなります。

-----

#### **オフラインでの動作**

`serverTimestamp()` はオフラインでも安全に利用できます。

1.  **オフライン中**: アプリがオフラインの状態で `serverTimestamp()` を含む書き込みを行うと、Firestore SDKは一時的に `null` として値を保持し、ローカルで書き込みを完了させます。
2.  **オンライン復帰後**: アプリが再びオンラインになると、SDKは保留されていた書き込みをサーバーに送信します。その際、`null` だったフィールドが**サーバーに到達した時点のタイムスタンプ**に置き換えられます。

この仕組みにより、オフラインで作成された投稿でも、オンラインになった瞬間の正しい時刻を記録できます。

-----

#### **セキュリティルールでの利用**

セキュリティルール内で `request.time` を使うことで、クライアントから送信されたタイムスタンプがサーバーの時刻と大きくずれていないかを検証できます。これにより、不正な時刻での書き込みを防ぐことができます。

```javascript
// posts/{postId}への書き込みを許可するルール
allow write: if request.time == resource.data.createdAt;
```

-----

#### **まとめ**

`serverTimestamp()` は、Firestoreで**信頼できる時刻情報**を扱うための必須機能です。特に、ユーザーの操作日時が重要になるアプリケーション（SNS、チャット、ログ記録など）では、クライアントの `new Date()` ではなく `serverTimestamp()` を利用することが強く推奨されます。これにより、データの整合性と信頼性が大幅に向上します。

## 一区切り
画面周りのページやコンポーネント周りの記事は別途作成します